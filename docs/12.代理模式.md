# 代理模式

- 使用者无权访问目标对象。
- 中间加代理，**通过代理做授权和控制**。

## 示例

- 科学上网、魔法丝袜。
- 在家办公，访问公司内网。（需要连到公司给的代理地址）
- 明星的经纪人。

## 说明

- 无

## UML 类图

- 预览地址：https://www.processon.com/view/link/60ad1b441e08531e9c830b2b

## ES6 语法最简易模型

- 代码目录：`./src/12.代理模式-demo.js`

---

## 经典使用场景

- 网页事件代理
- jQuery - $.proxy
- ES6 Proxy

---

### ES7 装饰器

- 配置环境
  - 安装插件：`babel-plugin-transform-decorators-legacy`
  - `.babelrc配置`：`"plugins": ["transform-decorators-legacy"]`
- 装饰类
- 装饰方法

```js
// 装饰类
@testDec
class Demo {}

function testDec(target) {
  target.isDec = true
}
// 测试用例
alert(Demo.isDec)

// * -----------------------------------------

// 传参数
@testDec(true)
class Demo {}

function testDec(isDec) {
  return function (target) {
    target.isDec = isDec
  }
}

// 测试用例
alert(Demo.isDec)
```

```js
// 装饰方法
class Person {
  constructor() {
    this.first = 'A'
    this.last = 'B'
  }

  @readonly
  name2() {
    alert(this.first)
    alert(this.last)
  }
}

function readonly(target, name, descriptor) {
  // console.log('target', target)
  // console.log('name', name)
  // descriptor: 属性描述对象(Object.defineProperty 中会用到)
  descriptor.writable = false
  return descriptor
}

// 测试用例

const cain = new Person()
cain.name2()
// 下面的不可行
// cain.name() = function(){}
// 预期会报错，说找不到 name 方法，因为 name 是只读属性
```

---

### core-decorators

- 第三方开源 lib。
- 提供常用的装饰器。
- 查阅文档：https://github.com/jayphelps/core-decorators
- 示例代码目录： `./src/装饰器模式-core-decorators.js`

---

## 设计原则验证

- 将 **现有对象** 和 **装饰器** 进行分离，两者独立存在。
- 符合开放封闭原则。
